import os
import logging
import pandas as pd
import vectorbt as vbt
import matplotlib.pyplot as plt
from core.metrics import calculate_metrics
from config import config
import glob

logger = logging.getLogger(__name__)


class Backtester:

    def __init__(self, strategy, price_data: pd.DataFrame):
        self.strategy = strategy
        self.price_data = price_data

    def run(self):
        """
        Runs the backtest.

        Returns:
            vbt.Portfolio: The backtest results or None if an error occurred.
        """
        logger.info("Running generate_signals()")
        signals = self.strategy.generate_signals()

        if signals is None or signals.empty:
            logger.warning("No signals generated by the strategy")
            return None

        # Ensure signals have same index as price data
        signals = signals.reindex(self.price_data.index).fillna(0).astype(int)

        if not signals.index.equals(self.price_data.index):
            logger.error("Signal and price_data index mismatch after reindexing")
            return None

        # Save signals for debugging
        os.makedirs("logs", exist_ok=True)
        debug_path = os.path.join(
            "logs", f"{self.strategy.__class__.__name__.lower()}_signals.csv"
        )
        signals.to_csv(debug_path)
        logger.info(f"Signals saved to {debug_path}")

        close = self.price_data.xs("close", level="ohlcv", axis=1)
        logger.info("Running portfolio simulation via VectorBT")
        try:
            entries = (signals == 1).astype(bool)
            exits = (signals == -1).astype(bool)

            assert entries.index.equals(close.index)
            assert entries.columns.equals(close.columns)

            portfolio = vbt.Portfolio.from_signals(
                close=close,
                entries=entries,
                exits=exits,
                fees=float(config.commission),
                slippage=float(config.slippage),
                freq=config.timeframe,
            )

            logger.info("Portfolio simulation completed")
            return portfolio
        except Exception as e:
            logger.exception("Error during portfolio simulation")
            return None

    def save_results(self, portfolio, strategy_name: str):
        """Main method to save all result artifacts."""
        if portfolio is None:
            logger.warning("No portfolio to save results for")
            return

        logger.info("Saving portfolio metrics and equity curve")
        self._save_metrics(portfolio, strategy_name)
        self._save_equity_curve(portfolio, strategy_name)
        self._save_heatmap(portfolio, strategy_name)

    def _save_metrics(self, portfolio, strategy_name: str):
        """Calculate and save portfolio metrics as CSV."""
        try:
            metrics = calculate_metrics(portfolio)
            os.makedirs("results", exist_ok=True)
            path = f"results/{strategy_name}_metrics.csv"
            metrics.to_csv(path)
            logger.info(f"Metrics saved to {path}")
        except Exception:
            logger.exception("Error calculating or saving metrics")

    def _save_equity_curve(self, portfolio, strategy_name: str):
        """Plot and save equity curve as PNG."""
        try:
            total_equity = portfolio.value().sum(axis=1)
            plt.figure(figsize=(10, 6))
            plt.plot(total_equity, label="Total Equity", color="blue")
            plt.title(f"Equity Curve - {strategy_name}")
            plt.xlabel("Time")
            plt.ylabel("Equity")
            plt.legend()
            plt.grid(True)
            os.makedirs("results/screenshots", exist_ok=True)
            path = f"results/screenshots/{strategy_name}_equity.png"
            plt.savefig(path)
            plt.close()
            logger.info(f"Equity curve saved to {path}")
        except Exception:
            logger.exception("Error saving equity curve")

    def _save_heatmap(self, portfolio, strategy_name: str):
        """Plot and save total return per symbol as heatmap (bar plot)."""
        try:
            total_return = portfolio.total_return()
            fig, ax = plt.subplots(figsize=(12, 6))
            total_return.plot(kind="bar", ax=ax, color="skyblue")
            ax.set_title(f"Total Return per Symbol - {strategy_name}")
            ax.set_xlabel("Symbol")
            ax.set_ylabel("Return (%)")
            ax.grid(True)
            plt.tight_layout()
            path = f"results/screenshots/{strategy_name}_heatmap.png"
            plt.savefig(path)
            plt.close()
            logger.info(f"Heatmap saved to {path}")
        except Exception:
            logger.exception("Error saving heatmap")

    @classmethod
    def compare_strategies_metrics(
        cls, results_dir="results", output_file="strategy_comparison.csv"
    ):
        """
        Load, compare, and visualize strategy metrics.
        """
        logger.info("Comparing strategy metrics...")
        metrics_dfs = cls._load_all_metrics(results_dir)
        if metrics_dfs.empty:
            logger.warning("No metrics found for comparison.")
            return pd.DataFrame()

        cls._save_combined_metrics(metrics_dfs, results_dir, output_file)
        cls._plot_total_return(metrics_dfs, results_dir)

        return metrics_dfs

    @staticmethod
    def _load_all_metrics(results_dir: str) -> pd.DataFrame:
        """
        Load all *_metrics.csv files from directory.
        """
        metrics_files = glob.glob(os.path.join(results_dir, "*_metrics.csv"))
        all_metrics = []

        for file in metrics_files:
            try:
                strategy_name = os.path.basename(file).replace("_metrics.csv", "")
                df = pd.read_csv(file, index_col=0)
                df["strategy"] = strategy_name
                all_metrics.append(df)
            except Exception as e:
                logger.warning(f"Failed to read metrics from {file}: {e}")

        if all_metrics:
            combined = pd.concat(all_metrics)
            return combined.set_index("strategy")
        return pd.DataFrame()

    @staticmethod
    def _save_combined_metrics(df: pd.DataFrame, results_dir: str, output_file: str):
        """
        Save combined metrics table to CSV.
        """
        os.makedirs(results_dir, exist_ok=True)
        output_path = os.path.join(results_dir, output_file)
        df.to_csv(output_path)
        logger.info(f"Strategy comparison saved to {output_path}")

    @staticmethod
    def _plot_total_return(df: pd.DataFrame, results_dir: str):
        """
        Plot Total Return for each strategy and save as PNG.
        """
        try:
            plot_path = os.path.join(
                results_dir, "screenshots", "strategy_comparison_total_return.png"
            )
            os.makedirs(os.path.dirname(plot_path), exist_ok=True)

            # Ensure index is clean and proper column exists
            df = df.reset_index()
            df = df[["strategy", "Total Return [%]"]].dropna()

            # Sort values for plotting
            df = df.sort_values("Total Return [%]")

            plt.figure(figsize=(10, 6))
            plt.barh(df["strategy"], df["Total Return [%]"], color="skyblue")
            plt.title("Total Return Comparison by Strategy")
            plt.xlabel("Total Return [%]")
            plt.tight_layout()
            plt.savefig(plot_path)
            plt.close()
            logger.info(f"Comparison chart saved to {plot_path}")
        except Exception as e:
            logger.warning(f"Failed to generate comparison chart: {e}")


def run_strategy(strategy):
    """Run backtest for a given strategy instance and save results."""
    strategy_name = strategy.__class__.__name__

    try:
        logger.info(f"Starting backtest for {strategy_name}")

        backtester = Backtester(strategy, strategy.price_data)
        portfolio = backtester.run()

        logger.info(f"Backtest completed for {strategy_name}, saving results")
        backtester.save_results(portfolio, strategy_name.lower())
        logger.info(f"Results saved successfully for {strategy_name}")

    except Exception as e:
        logger.error(
            f"Error running backtest for {strategy_name}: {e}",
            exc_info=True,
        )
